#pragma once
/*
 *   The following code is generated by HParser
 *   By Htto 2023
 *   Github: https://github.com/HttoHu/hparser
 */
#define PRINT_INDENT 2
#include <iostream>
#include <vector>
#include <map>
#include <memory>
#include <set>
#include <variant>
#include <algorithm>
#include "lexer.h"

namespace HParser
{
    namespace
    {
        template <typename T>
        std::vector<T> move_vec(std::vector<T> &v)
        {
            std::vector<T> res;
            for (auto &item : v)
                res.push_back(std::move(item));
            v.clear();
            return res;
        }
    }
    class Symbol
    {
    public:
        bool is_terminal() const { return is_ter; }
        std::set<Symbol *> follows;
        std::set<Symbol *> firsts;
        std::vector<int> prods;

        enum SymType
        {
            COMMON, // common symbol
            LR,     // the generated symbol when kill left recursive node
            LCF,    // the generated symbol when kill left common factors
        } type = COMMON;
        bool is_ter;

    private:
    };

    struct Production
    {
        std::vector<Symbol *> expr;
    };
    struct Context
    {
    public:
        ~Context()
        {
            for (auto [name, sym] : symb_tab)
                delete sym;
        }

    public:
        std::string get_name(Symbol *sym)
        {
            auto it = rsymb_tab.find(sym);
            if (it == rsymb_tab.end())
                throw std::runtime_error("Context::get_name(Symbol*): unknonwn symbol ");
            return it->second;
        }
        Symbol *get_symbol(const std::string &str)
        {
            auto it = symb_tab.find(str);
            if (it == symb_tab.end())
                throw std::runtime_error("Context::get_symbol(string): unknonwn symbol " + str);
            return it->second;
        }

    public:
    public:
        std::map<std::string, Symbol *> symb_tab;
        std::map<Symbol *, std::string> rsymb_tab;
        std::vector<Symbol *> prods_left;
        std::vector<Production> prods;
    };


    struct ASTNode;
    using ASTNodePtr = std::unique_ptr<ASTNode>;
    struct ASTNode
    {
    public:
        using data_type = std::variant<std::monostate, std::string, std::vector<ASTNodePtr>>;

        ASTNode(const std::string &_t, data_type &&_data, bool _is_leaf = false) : type(_t), data(std::move(_data)), is_leaf(_is_leaf) {}
        void print(int dep = 0)
        {
            for (int i = 0; i < dep; i++)
                std::cout << "|" << std::string(PRINT_INDENT - 1, ' ');
            if (is_leaf)
                std::cout << std::get<std::string>(data) << std::endl;
            else
            {
                std::cout << type << "\n";
                for (auto &item : std::get<std::vector<ASTNodePtr>>(data))
                    item->print(dep + 1);
            }
        }
        // chilren count
        size_t ch_size() const
        {
            return std::get<std::vector<ASTNodePtr>>(data).size();
        }
        ASTNodePtr &operator[](size_t idx)
        {
            return std::get<std::vector<ASTNodePtr>>(data)[idx];
        }
        ASTNodePtr &back()
        {
            return operator[](ch_size() - 1);
        }
        ASTNodePtr &front()
        {
            return operator[](0);
        }
        std::vector<ASTNodePtr> &children()
        {
            return std::get<std::vector<ASTNodePtr>>(data);
        }
        Symbol::SymType node_type = Symbol::COMMON;
        static void adjust_ast(ASTNodePtr &node)
        {
            using children_type = std::vector<ASTNodePtr>;
            if (node->is_leaf || node->children().size() == 0)
                return;

            children_type new_vec;
            auto &children = std::get<children_type>(node->data);
            if (node->back()->node_type == Symbol::LR)
            {
                auto cur = node->back().get();
                // epsilon
                if (cur->ch_size() == 0)
                {
                    if (children.size())
                        children.pop_back();
                }
                else
                {
                    // cur_node is an obeserver
                    while (cur->ch_size() != 0 && cur->back()->ch_size() != 0)
                        cur = cur->back().get();
                    ASTNodePtr new_node = std::make_unique<ASTNode>(node->type, move_vec(children));
                    children.push_back(std::move(new_node));

                    cur->children().pop_back();
                    auto new_right_part = move_vec(cur->children());
                    // attach right part
                    for (auto &i : new_right_part)
                        children.push_back(std::move(i));
                    adjust_ast(node->front());
                }
            }

            for (auto &child : children)
            {
                if (child->node_type == Symbol::COMMON)
                {
                    adjust_ast(child);
                    new_vec.emplace_back(std::move(child));
                }
                else if (child->node_type == Symbol::LCF)
                {
                    adjust_ast(child);
                    for (auto &gchild : std::get<children_type>(child->data))
                        new_vec.emplace_back(std::move(gchild));
                }
                else
                {
                    std::cout << child->type << "\n";
                }
            }
            children = std::move(new_vec);
        }

    public:
        std::string type;
        bool is_leaf;

        data_type data;
    };
    // to recover original parser tree after kill left common factor and left recursive.
    struct LLParser
    {
        LLParser()
        {
            std::vector<Symbol *> v(22);

            for (int i = 0; i < v.size(); i++)
            {
                v[i] = new Symbol();
            }
            v[0]->type = (Symbol::SymType)0;
            v[0]->is_ter = 0;
            v[1]->type = (Symbol::SymType)1;
            v[1]->is_ter = 0;
            v[2]->type = (Symbol::SymType)0;
            v[2]->is_ter = 0;
            v[3]->type = (Symbol::SymType)0;
            v[3]->is_ter = 0;
            v[4]->type = (Symbol::SymType)0;
            v[4]->is_ter = 0;
            v[5]->type = (Symbol::SymType)0;
            v[5]->is_ter = 0;
            v[6]->type = (Symbol::SymType)1;
            v[6]->is_ter = 0;
            v[7]->type = (Symbol::SymType)0;
            v[7]->is_ter = 1;
            v[8]->type = (Symbol::SymType)0;
            v[8]->is_ter = 1;
            v[9]->type = (Symbol::SymType)0;
            v[9]->is_ter = 1;
            v[10]->type = (Symbol::SymType)0;
            v[10]->is_ter = 1;
            v[11]->type = (Symbol::SymType)0;
            v[11]->is_ter = 1;
            v[12]->type = (Symbol::SymType)0;
            v[12]->is_ter = 1;
            v[13]->type = (Symbol::SymType)0;
            v[13]->is_ter = 1;
            v[14]->type = (Symbol::SymType)0;
            v[14]->is_ter = 1;
            v[15]->type = (Symbol::SymType)0;
            v[15]->is_ter = 1;
            v[16]->type = (Symbol::SymType)0;
            v[16]->is_ter = 1;
            v[17]->type = (Symbol::SymType)0;
            v[17]->is_ter = 1;
            v[18]->type = (Symbol::SymType)2;
            v[18]->is_ter = 0;
            v[19]->type = (Symbol::SymType)2;
            v[19]->is_ter = 0;
            v[20]->type = (Symbol::SymType)2;
            v[20]->is_ter = 0;
            v[21]->type = (Symbol::SymType)2;
            v[21]->is_ter = 0;
            context = std::make_unique<Context>();
            context->prods_left = {v[4], v[19], v[19], v[18], v[20], v[20], v[21], v[2], v[2], v[2], v[3], v[3], v[3], v[0], v[1], v[6], v[5], v[1], v[6]};
            context->prods.resize(19);
            context->prods[0].expr = {v[0], v[10]};
            context->prods[1].expr = {v[7], v[5]};
            context->prods[2].expr = {v[16], v[5]};
            context->prods[4].expr = {v[12], v[2]};
            context->prods[5].expr = {v[9], v[2]};
            context->prods[7].expr = {v[13]};
            context->prods[8].expr = {v[11], v[0], v[14]};
            context->prods[9].expr = {v[3]};
            context->prods[10].expr = {v[15], v[11], v[0], v[14]};
            context->prods[11].expr = {v[8], v[11], v[0], v[14]};
            context->prods[12].expr = {v[17], v[11], v[0], v[14]};
            context->prods[13].expr = {v[5], v[18], v[1]};
            context->prods[14].expr = {v[19], v[1]};
            context->prods[15].expr = {v[20], v[6]};
            context->prods[16].expr = {v[2], v[21], v[6]};
            context->symb_tab = {{"E", v[0]}, {"E\'", v[1]}, {"F", v[2]}, {"Func", v[3]}, {"S", v[4]}, {"T", v[5]}, {"T\'", v[6]}, {"add", v[7]}, {"cos", v[8]}, {"div", v[9]}, {"end", v[10]}, {"lp", v[11]}, {"mul", v[12]}, {"num", v[13]}, {"rp", v[14]}, {"sin", v[15]}, {"sub", v[16]}, {"tan", v[17]}, {"~E0", v[18]}, {"~E1", v[19]}, {"~T0", v[20]}, {"~T1", v[21]}};

            for (auto [k, v] : context->symb_tab)
                context->rsymb_tab.insert({v, k});
            start = "S";
            ll_tab[v[5]] = {{"cos", 16}, {"lp", 16}, {"num", 16}, {"sin", 16}, {"tan", 16}};
            ll_tab[v[2]] = {{"cos", 9}, {"lp", 8}, {"num", 7}, {"sin", 9}, {"tan", 9}};
            ll_tab[v[19]] = {{"add", 1}, {"sub", 2}};
            ll_tab[v[1]] = {{"add", 14}, {"end", 17}, {"rp", 17}, {"sub", 14}};
            ll_tab[v[20]] = {{"div", 5}, {"mul", 4}};
            ll_tab[v[6]] = {{"add", 18}, {"div", 15}, {"end", 18}, {"mul", 15}, {"rp", 18}, {"sub", 18}};
            ll_tab[v[21]] = {{"add", 6}, {"div", 6}, {"end", 6}, {"mul", 6}, {"rp", 6}, {"sub", 6}};
            ll_tab[v[4]] = {{"cos", 0}, {"lp", 0}, {"num", 0}, {"sin", 0}, {"tan", 0}};
            ll_tab[v[0]] = {{"cos", 13}, {"lp", 13}, {"num", 13}, {"sin", 13}, {"tan", 13}};
            ll_tab[v[3]] = {{"cos", 11}, {"sin", 10}, {"tan", 12}};
            ll_tab[v[18]] = {{"add", 3}, {"end", 3}, {"rp", 3}, {"sub", 3}};
        }

        ASTNodePtr parse(const std::vector<HLex::Token> &toks)
        {
            struct StacNode
            {
                enum Type
                {
                    SYMBOL,
                    POP
                } type;
                StacNode(Type t, Symbol *sym) : type(t), symbol(sym) {}
                Symbol *symbol;
                // if the type is pop, then pop such nodes
                int production_symbol_cnt = 0;
            };

            int pos = 0;
            std::vector<StacNode> parsing_stac;
            std::vector<ASTNodePtr> tree_nodes;

            // init parsing_stac with reverse order. because it is a stack
            auto start_symbol = context->get_symbol(start);
            parsing_stac.push_back(StacNode(StacNode::SYMBOL, start_symbol));

            while (parsing_stac.size())
            {
                auto top_symbol = parsing_stac.back();
                parsing_stac.pop_back();
                if (top_symbol.type == StacNode::SYMBOL)
                {
                    if (pos >= toks.size())
                        throw std::runtime_error("LLParser::parse: unexpected end");
                    auto cur_tok = toks[pos];
                    if (top_symbol.symbol->is_terminal())
                    {
                        if (cur_tok.tag == context->get_name(top_symbol.symbol))
                        {
                            auto node = std::make_unique<ASTNode>(cur_tok.tag, std::string(cur_tok.val), true);
                            node->node_type = Symbol::COMMON;
                            tree_nodes.push_back(std::move(node));
                        }
                        else
                            throw std::runtime_error("syntax error! unexpected token " + cur_tok.to_string());
                        pos++;
                    }
                    else
                    {
                        auto it = ll_tab[top_symbol.symbol].find(cur_tok.tag);
                        if (it == ll_tab[top_symbol.symbol].end())
                            throw std::runtime_error("syntax error! unexpected token " + cur_tok.to_string());
                        auto &production = context->prods[it->second].expr;
                        parsing_stac.push_back(StacNode(StacNode::POP, context->prods_left[it->second]));
                        parsing_stac.back().production_symbol_cnt = production.size();
                        for (int i = (int)production.size() - 1; i >= 0; i--)
                            parsing_stac.push_back(StacNode(StacNode::SYMBOL, production[i]));
                    }
                }
                else if (top_symbol.type == StacNode::POP)
                {
                    std::string node_type = context->get_name(top_symbol.symbol);
                    int cnt = top_symbol.production_symbol_cnt;
                    if (tree_nodes.size() < cnt)
                        throw std::runtime_error("ASTNodePtr LLParser::parse :internal error!");
                    std::vector<ASTNodePtr> nodes;
                    // get back nodes and merge to a new node
                    while (cnt)
                        nodes.push_back(std::move(tree_nodes.back())), tree_nodes.pop_back(), cnt--;
                    std::reverse(nodes.begin(), nodes.end());
                    auto new_node = std::make_unique<ASTNode>(node_type, std::move(nodes));
                    new_node->node_type = top_symbol.symbol->type;
                    tree_nodes.push_back(std::move(new_node));
                }
            }
            if (tree_nodes.size() != 1)
                throw std::runtime_error("LLParser::parse : syntax error!");
            ASTNode::adjust_ast(tree_nodes.front());
            return std::move(tree_nodes.front());
        }

        std::string start;
        std::unique_ptr<Context> context;
        std::map<Symbol *, std::map<std::string, int>> ll_tab;
    };
}