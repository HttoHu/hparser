#include <iostream>
#include <string>
#include <vector>
#include <map>
#include <set>
#include <functional>
#include <fstream>
#include "../includes/scanner.h"
namespace HLex
{
    using std::map;
    using std::vector;
    using char_type = char;
    void print_line(const std::string &s, int &pos)
    {
        int cnt = 100;
        while (pos < s.size() && cnt)
        {
            std::cout << s[pos++];
            cnt--;
        }
        std::cout.flush();
    }
    class Lexer
    {
    public:
        Lexer(const std::string &con);
        std::vector<Token> lex()
        {
            std::vector<Token> ret;
            int cur_state = entry;
            // to roll back state tag val
            std::vector<std::pair<int, Token>> pos_stac;
            // str pos
            int pos = 0;
            std::string cur_token;
            std::string cur_tag;

            while (pos < content.size())
            {
                if (tab[cur_state].count(content[pos]))
                {
                    cur_state = tab[cur_state][content[pos]];
                    cur_token += content[pos];

                    if (fin_stat_tab.count(cur_state))
                    {
                        if (fin_stat_tab[cur_state] != "")
                            cur_tag = fin_stat_tab[cur_state];

                        pos_stac.clear();
                        pos_stac.push_back({pos + 1, {cur_tag, cur_token}});
                    }
                    pos++;
                }
                else
                {
                    if (pos_stac.empty())
                    {
                        print_line(content, pos);
                        throw std::runtime_error(" LexerGenerator::lex: Lexer Error");
                    }
                    auto [p, tok] = pos_stac.back();
                    // if a symbol is a keyword pr ignore
                    auto val = tok.val;
                    if (keywords.count(val))
                        tok = Token{keywords[val], val};
                    if (user_defs.count(tok.tag))
                    {
                        p -= tok.val.size();
                        tok.val = user_defs[tok.tag](content, p);
                    }
                    if (!ignore.count(tok.tag))
                        ret.push_back(tok);

                    // roll back
                    pos = p;
                    cur_state = entry;
                    cur_token = cur_tag = "";
                    pos_stac.clear();
                }
            }
            if (pos_stac.size())
                ret.push_back(pos_stac.back().second);
            return ret;
        }

    private:
        std::string content;
        int pos = 0;

        std::map<std::string, std::string> keywords;
        std::map<std::string, std::function<std::string(const std::string &, int &)>> user_defs;
        std::set<std::string> ignore;

        int entry;
        map<int, std::string> fin_stat_tab;
        vector<map<char_type, int>> tab;
    };

    std::string read_file(const std::string &filename)
    {
        std::ifstream ifs(filename, std::ios::in | std::ios::binary);
        if (!ifs)
            throw std::runtime_error("open file " + filename + " failed\n");
        char *file_content;
        ifs.seekg(0, std::ios::end);
        size_t file_length = ifs.tellg();
        ifs.seekg(0, std::ios::beg);

        file_content = new char[file_length];

        ifs.read(file_content, file_length);
        ifs.close();

        std::string str(file_content, file_content + file_length);
        delete[] file_content;
        return str;
    }
}
// Following code is generated by program
namespace HLex
{
    Lexer::Lexer(const std::string &con) : content(con), entry(9)
    {
        fin_stat_tab = {{1, "annotation"}, {2, "colon"}, {3, "newline"}, {4, "nterminal"}, {5, "or"}, {6, "semi"}, {7, "space"}, {8, "terminal"}};
        tab = {{{'0', 13}, {'1', 13}, {'2', 13}, {'3', 13}, {'4', 13}, {'5', 13}, {'6', 13}, {'7', 13}, {'8', 13}, {'9', 13}, {'A', 13}, {'B', 13}, {'C', 13}, {'D', 13}, {'E', 13}, {'F', 13}, {'G', 13}, {'H', 13}, {'I', 13}, {'J', 13}, {'K', 13}, {'L', 13}, {'M', 13}, {'N', 13}, {'O', 13}, {'P', 13}, {'Q', 13}, {'R', 13}, {'S', 13}, {'T', 13}, {'U', 13}, {'V', 13}, {'W', 13}, {'X', 13}, {'Y', 13}, {'Z', 13}, {'a', 13}, {'b', 13}, {'c', 13}, {'d', 13}, {'e', 13}, {'f', 13}, {'g', 13}, {'h', 13}, {'i', 13}, {'j', 13}, {'k', 13}, {'l', 13}, {'m', 13}, {'n', 13}, {'o', 13}, {'p', 13}, {'q', 13}, {'r', 13}, {'s', 13}, {'t', 13}, {'u', 13}, {'v', 13}, {'w', 13}, {'x', 13}, {'y', 13}, {'z', 13}}, {}, {}, {}, {}, {}, {}, {}, {}, {{'\t', 7}, {'\n', 3}, {'\r', 10}, {' ', 7}, {'#', 1}, {':', 2}, {';', 6}, {'<', 12}, {'[', 0}, {'|', 5}}, {{'\n', 3}}, {{'0', 11}, {'1', 11}, {'2', 11}, {'3', 11}, {'4', 11}, {'5', 11}, {'6', 11}, {'7', 11}, {'8', 11}, {'9', 11}, {'>', 8}, {'A', 11}, {'B', 11}, {'C', 11}, {'D', 11}, {'E', 11}, {'F', 11}, {'G', 11}, {'H', 11}, {'I', 11}, {'J', 11}, {'K', 11}, {'L', 11}, {'M', 11}, {'N', 11}, {'O', 11}, {'P', 11}, {'Q', 11}, {'R', 11}, {'S', 11}, {'T', 11}, {'U', 11}, {'V', 11}, {'W', 11}, {'X', 11}, {'Y', 11}, {'Z', 11}, {'a', 11}, {'b', 11}, {'c', 11}, {'d', 11}, {'e', 11}, {'f', 11}, {'g', 11}, {'h', 11}, {'i', 11}, {'j', 11}, {'k', 11}, {'l', 11}, {'m', 11}, {'n', 11}, {'o', 11}, {'p', 11}, {'q', 11}, {'r', 11}, {'s', 11}, {'t', 11}, {'u', 11}, {'v', 11}, {'w', 11}, {'x', 11}, {'y', 11}, {'z', 11}}, {{'0', 11}, {'1', 11}, {'2', 11}, {'3', 11}, {'4', 11}, {'5', 11}, {'6', 11}, {'7', 11}, {'8', 11}, {'9', 11}, {'A', 11}, {'B', 11}, {'C', 11}, {'D', 11}, {'E', 11}, {'F', 11}, {'G', 11}, {'H', 11}, {'I', 11}, {'J', 11}, {'K', 11}, {'L', 11}, {'M', 11}, {'N', 11}, {'O', 11}, {'P', 11}, {'Q', 11}, {'R', 11}, {'S', 11}, {'T', 11}, {'U', 11}, {'V', 11}, {'W', 11}, {'X', 11}, {'Y', 11}, {'Z', 11}, {'a', 11}, {'b', 11}, {'c', 11}, {'d', 11}, {'e', 11}, {'f', 11}, {'g', 11}, {'h', 11}, {'i', 11}, {'j', 11}, {'k', 11}, {'l', 11}, {'m', 11}, {'n', 11}, {'o', 11}, {'p', 11}, {'q', 11}, {'r', 11}, {'s', 11}, {'t', 11}, {'u', 11}, {'v', 11}, {'w', 11}, {'x', 11}, {'y', 11}, {'z', 11}}, {{'0', 13}, {'1', 13}, {'2', 13}, {'3', 13}, {'4', 13}, {'5', 13}, {'6', 13}, {'7', 13}, {'8', 13}, {'9', 13}, {'A', 13}, {'B', 13}, {'C', 13}, {'D', 13}, {'E', 13}, {'F', 13}, {'G', 13}, {'H', 13}, {'I', 13}, {'J', 13}, {'K', 13}, {'L', 13}, {'M', 13}, {'N', 13}, {'O', 13}, {'P', 13}, {'Q', 13}, {'R', 13}, {'S', 13}, {'T', 13}, {'U', 13}, {'V', 13}, {'W', 13}, {'X', 13}, {'Y', 13}, {'Z', 13}, {']', 4}, {'a', 13}, {'b', 13}, {'c', 13}, {'d', 13}, {'e', 13}, {'f', 13}, {'g', 13}, {'h', 13}, {'i', 13}, {'j', 13}, {'k', 13}, {'l', 13}, {'m', 13}, {'n', 13}, {'o', 13}, {'p', 13}, {'q', 13}, {'r', 13}, {'s', 13}, {'t', 13}, {'u', 13}, {'v', 13}, {'w', 13}, {'x', 13}, {'y', 13}, {'z', 13}}};
        ignore = {"annotation", "space"};
        keywords = {};
        user_defs = {{"annotation", [](const std::string &s, int &pos)
                      {
                          while (pos < s.size() && s[pos] != '\n')
                              pos++;
                          return "";
                      }}};
    }
    Scanner scanner(const std::string &str)
    {
        Lexer L(str);
        Scanner ret;
        ret.data = L.lex();
        return ret;
    }
}